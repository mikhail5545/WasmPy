use std::collections::HashMap;
use crate::instruction::*;

/// A simple register-based virtual machine that executes a sequence of instructions.
pub struct RegisterVM{
    /// A fixed-size array of registers, where each register can hold a Value. The VM supports up to 256 registers (0-255).
    registers: [Value; 256],
    /// The list of instructions to execute, which is typically generated by a compiler from source code.
    instructions: Vec<Instruction>,
    /// Current instruction pointer, which tracks the index of the next instruction to execute in the instructions vector.
    ip: usize,
    /// A mapping of global variable names to their values, used for variable storage and lookup during execution.
    globals: HashMap<String, Value>,
}

impl RegisterVM{
    pub fn new(instructions: Vec<Instruction>) -> Self{
        Self{
            registers: std::array::from_fn(|_| Value::None),
            instructions,
            ip: 0,
            globals: HashMap::new(),
        }
    }

    pub fn run(&mut self) {
        loop {
            if self.ip >= self.instructions.len() {
                break;
            }
            let instruction = self.instructions[self.ip].clone();
            self.ip += 1; // Move to the next instruction by default

            match instruction {
                Instruction::LoadConst(reg, val) => {
                    self.registers[reg as usize] = val;
                }
                Instruction::LoadName(reg, name) => {
                    let val = self.globals.get(&name).cloned().unwrap_or(Value::None);
                    self.registers[reg as usize] = val;
                }
                Instruction::StoreName(name, reg) => {
                    let val = self.registers[reg as usize].clone();
                    self.globals.insert(name, val);
                }
                Instruction::BinOp(dest, op, left, right) => {
                    let left_val = &self.registers[left as usize];
                    let right_val = &self.registers[right as usize];
                    self.registers[dest as usize] = Self::eval_binop(op, left_val, right_val);
                }
                Instruction::UnaryOp(dest, op, src) => {
                    let operand = &self.registers[src as usize];
                    self.registers[dest as usize] = Self::eval_unary_op(op, operand);
                }
                Instruction::Compare(dest, op, left, right) => {
                    let left_val = &self.registers[left as usize];
                    let right_val = &self.registers[right as usize];
                    self.registers[dest as usize] = Self::eval_compare(op, left_val, right_val);
                }
                Instruction::JumpIfFalse(reg, target) => {
                    let condition = &self.registers[reg as usize];
                    if !Self::is_truthy(condition) {
                        self.ip = target;
                    }
                }
                Instruction::Jump(target) => {
                    self.ip = target;
                }
                Instruction::Move(dest, src) => {
                    self.registers[dest as usize] = self.registers[src as usize].clone(); // Clone from source
                }
                Instruction::Print(reg) => {
                    println!("{:?}", Self::display_value(&self.registers[reg as usize]));
                }
                // TODO: implement Call instruction for function calls, which will require managing a call stack and possibly closures for variable scopes.
                Instruction::Return(_reg) => {
                    // FIXME: Not implemented
                    break;
                }
                Instruction::Call(..) => {
                    // FIXME: Not implemented
                    break;
                }
                Instruction::Halt => break,
            }
        }
    }
    
    /// Evaluates a binary operation on two values, returning the result as a new Value. 
    /// This function handles type checking and operator semantics for supported operations.
    fn eval_binop(op: BinOpKind, left: &Value, right: &Value) -> Value{
        match (op, left, right) {
            // --- Value::Int ---
            (BinOpKind::Add, Value::Int(a), Value::Int(b)) => Value::Int(a + b),
            (BinOpKind::Sub, Value::Int(a), Value::Int(b)) => Value::Int(a - b),
            (BinOpKind::Mul, Value::Int(a), Value::Int(b)) => Value::Int(a * b),
            // Note: this is integer division, which truncates value towards zero (default '/' rust behaviour). For example, -3 // 2 == -1, while in Python -3 // 2 == -2.
            (BinOpKind::Div, Value::Int(a), Value::Int(b)) => Value::Int(a / b),
            (BinOpKind::Pow, Value::Int(a), Value::Int(b)) => Value::Int(a.pow(*b as u32)),
            (BinOpKind::Mod, Value::Int(a), Value::Int(b)) => Value::Int(a % b),
            // TODO: Add floor division for integers and floating point numbers
            (BinOpKind::FloorDiv, Value::Int(a), Value::Int(b)) => Value::Int(a / b),
            // --- Value::Float ---
            (BinOpKind::Add, Value::Float(a), Value::Float(b)) => Value::Float(a + b),
            (BinOpKind::Sub, Value::Float(a), Value::Float(b)) => Value::Float(a - b),
            (BinOpKind::Mul, Value::Float(a), Value::Float(b)) => Value::Float(a * b),
            // Note: this is floating point division, which does not truncate value. For example, -3.0 / 2.0 == -1.5, while in Python -3.0 // 2.0 == -2.0.
            (BinOpKind::Div, Value::Float(a), Value::Float(b)) => Value::Float(a / b),
            // --- String concatenation ---
            (BinOpKind::Add, Value::Str(a), Value::Str(b)) => Value::Str(format!("{}{}", a, b)),
            // --- Boolean operations ---
            (BinOpKind::And, Value::Bool(a), Value::Bool(b)) => Value::Bool(*a && *b),
            (BinOpKind::Or, Value::Bool(a), Value::Bool(b)) => Value::Bool(*a || *b),
            _ => Value::None, // For unsupported operations, return None
        }
    }
    
    /// Evaluates a unary operation on a value, returning the result as a new Value.
    fn eval_unary_op(op: UnaryOpKind, operand: &Value) -> Value{
        match (op, operand) {
            (UnaryOpKind::Neg, Value::Int(a)) => Value::Int(-a),
            (UnaryOpKind::Neg, Value::Float(a)) => Value::Float(-a),
            (UnaryOpKind::Not, v) => Value::Bool(!Self::is_truthy(v)),
            (UnaryOpKind::Invert, Value::Int(a)) => Value::Int(!a),
            _ => Value::None, // For unsupported operations, return None
        }
    }
    
    /// Evaluates a comparison operation between two values, returning the result as a new Value::Bool. 
    /// This function handles type checking and operator semantics for supported comparisons.
    fn eval_compare(op: CmpOpKind, left: &Value, right: &Value) -> Value{
        match(op, left, right) {
            // --- Value::Int ---
            (CmpOpKind::Eq, Value::Int(a), Value::Int(b)) => Value::Bool(a == b),
            (CmpOpKind::NotEq, Value::Int(a), Value::Int(b)) => Value::Bool(a != b),
            (CmpOpKind::Lt, Value::Int(a), Value::Int(b)) => Value::Bool(a < b),
            (CmpOpKind::Gt, Value::Int(a), Value::Int(b)) => Value::Bool(a > b),
            (CmpOpKind::LtE, Value::Int(a), Value::Int(b)) => Value::Bool(a <= b),
            (CmpOpKind::GtE, Value::Int(a), Value::Int(b)) => Value::Bool(a >= b),
            // --- Value::Float ---
            (CmpOpKind::Eq, Value::Float(a), Value::Float(b)) => Value::Bool(a == b),
            (CmpOpKind::NotEq, Value::Float(a), Value::Float(b)) => Value::Bool(a != b),
            (CmpOpKind::Lt, Value::Float(a), Value::Float(b)) => Value::Bool(a < b),
            (CmpOpKind::Gt, Value::Float(a), Value::Float(b)) => Value::Bool(a > b),
            (CmpOpKind::LtE, Value::Float(a), Value::Float(b)) => Value::Bool(a <= b),
            (CmpOpKind::GtE, Value::Float(a), Value::Float(b)) => Value::Bool(a >= b),
            // --- Value::Str ---
            (CmpOpKind::Eq, Value::Str(a), Value::Str(b)) => Value::Bool(a == b),
            (CmpOpKind::NotEq, Value::Str(a), Value::Str(b)) => Value::Bool(a != b),
            (CmpOpKind::Lt, Value::Str(a), Value::Str(b)) => Value::Bool(a < b),
            (CmpOpKind::Gt, Value::Str(a), Value::Str(b)) => Value::Bool(a > b),
            (CmpOpKind::LtE, Value::Str(a), Value::Str(b)) => Value::Bool(a <= b),
            (CmpOpKind::GtE, Value::Str(a), Value::Str(b)) => Value::Bool(a >= b),
            // --- Value::Bool ---
            (CmpOpKind::Eq, Value::Bool(a), Value::Bool(b)) => Value::Bool(a == b),
            (CmpOpKind::NotEq, Value::Bool(a), Value::Bool(b)) => Value::Bool(a != b),
            (CmpOpKind::Lt, Value::Bool(a), Value::Bool(b)) => Value::Bool(!a && *b), // False < True
            (CmpOpKind::Gt, Value::Bool(a), Value::Bool(b)) => Value::Bool(*a && !b), // True > False
            (CmpOpKind::LtE, Value::Bool(a), Value::Bool(b)) => Value::Bool(!a || *b), // False <= True, True <= True, False <= False
            (CmpOpKind::GtE, Value::Bool(a), Value::Bool(b)) => Value::Bool(*a || !b), // True >= False, True >= True, False
            // --- None comparisons ---
            (CmpOpKind::Eq, Value::None, Value::None) => Value::Bool(true),
            (CmpOpKind::NotEq, Value::None, Value::None) => Value::Bool(false),
            (CmpOpKind::Eq, Value::None, _) => Value::Bool(false),
            (CmpOpKind::Eq, _, Value::None) => Value::Bool(false),
            (CmpOpKind::NotEq, Value::None, _) => Value::Bool(true),
            (CmpOpKind::NotEq, _, Value::None) => Value::Bool(true),
            _ => Value::None, // For unsupported comparisons, return None
        }
    }

    /// Helper function to determine the "truthiness" of a value, used for boolean contexts like if conditions and while loops.
    fn is_truthy(value: &Value) -> bool{
        match value {
            Value::Int(i) => *i != 0,
            Value::Float(f) => *f != 0.0,
            Value::Str(s) => !s.is_empty(),
            Value::Bool(b) => *b,
            Value::None => false,
        }
    }

    /// Helper function to convert a Value to a string for debugging or printing purposes.
    fn display_value(value: &Value) -> String{
        match value{
            Value::Int(n) => n.to_string(),
            Value::Float(f) => f.to_string(),
            Value::Str(s) => s.clone(),
            Value::Bool(b) => (if *b { "True" } else { "False" }).to_string(),
            Value::None => "None".to_string(),
        }
    }
}

